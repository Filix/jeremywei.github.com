---
layout: post
title: Varnish安装配置
---

<p><strong>介绍</strong></p>

<p><em>“Varnish是一款高性能的开源HTTP加速器，挪威最大的在线报纸 Verdens Gang (<a href="http://www.vg.no" target="_blank">http://www.vg.no</a>) 使用3台Varnish代替了原来的12台squid，性能居然比以前更好。Varnish 的作者Poul-Henning Kamp是FreeBSD的内核开发者之一，他认为现在的计算机比起1975年已经复杂许多。在1975年时，储存媒介只有两种：内存与硬盘。但现在计算机系统的内存除了主存外，还包括了cpu内的L1、L2，甚至有L3快取。硬盘上也有自己的快取装置，因此squid cache自行处理物件替换的架构不可能得知这些情况而做到最佳化，但操作系统可以得知这些情况，所以这部份的工作应该交给操作系统处理，这就是Varnish cache设计架构。目前很多互联网公司在使用varnish，其中包括Facebook”</em><br/><span id="more-540"></span><br/><strong>特性</strong></p>

<ul><li><a href="http://www.varnish-cache.org/docs/2.1/reference/vcl.html" target="_blank">VCL</a>(Varnish Configuration Language)：区别于其他系统，Varnish采用了自身的配置语言来配置，非常容易上手，这些配置会被编译成二进制机器码，明显加快了执行速度。</li>

<li><a href="http://www.varnish-cache.org/docs/2.1/tutorial/advanced_backend_servers.html#health-checks" target="_blank">Health checks</a>：完善的健康检查机制。</li>

<li><a href="http://www.varnish-cache.org/docs/2.1/tutorial/esi.html" target="_blank">ESI</a>(Edge Side Includes)：在HTML中嵌入动态脚本文件。</li>

<li><a href="http://www.varnish-cache.org/docs/2.1/reference/vcl.html#directors" target="_blank">Directors</a>：后端服务器的调度方式：random，round-robin，client，hash，DNS。</li>

<li><a href="http://www.varnish-cache.org/docs/2.1/tutorial/purging.html" target="_blank">Purging and banning</a>：强大的缓存清除功能，可以以正则表达式的形式清除缓存。</li>

<li><a href="http://www.varnish-cache.org/docs/2.1/tutorial/logging.html" target="_blank">Logging in Varnish</a>：Varnish的log不是记录在文件中的，而是记录在共享内存中。当日志大小达到分配的共享内存容量，覆盖掉旧的日志。以这种方式记录日志比文件的形式要快很多，并且不需要磁盘空间。</li>

<li>丰富的管理程序：varnishadm，varnishtop，varnishhist，varnishstat以及varnishlog等。</li>

</ul><p><strong>环境</strong><br/><span>OS: CentOS 5.5</span><br/><span>varnish: 2.1.5</span></p>

<p><strong>安装</strong></p>

<pre>#如果没装ncurses-devel，那么varnishstat,varnishtop都无法编译好

yum install ncurses-devel

wget <a href="http://repo.varnish-cache.org/source/varnish-2.1.5.tar.gz" target="_blank">http://repo.varnish-cache.org/source/varnish-2.1.5.tar.gz</a>

tar -zxvf varnish-2.1.5.tar.gz

cd varnish-2.1.5

./configure --prefix=/usr/local/varnish-2.1.5

make &amp;&amp; make install

#以下方式启动

/usr/local/varnish2.1.5/sbin/varnishd -f /usr/local/varnish2.1.5/etc/varnish/default.vcl -T 127.0.0.1:2000 -a 0.0.0.0:80 -s file,/tmp,200M

#其中"-f"用来指定配置文件，"-T"指定管理台的访问地址，"-a"指定Varnish监听地址，"-s"指定Varnish以文件方式来缓存资源，地址为/tmp，大小200MB。

</pre>

<p><strong>配置</strong></p>

<pre>#后端处理器b1

backend b1{

    .host = "192.168.2.110";

    .port = "81";

    .connect_timeout = 5s;

    .first_byte_timeout= 5s;

    .probe = {

        #health check

        .url = "/check.txt";

        .interval = 5s;

        .timeout = 5s;

        .window = 5;

        .threshold = 3;

    }

}

#后端处理器b2

backend b2{

    .host = "192.168.2.109";

    .port = "81";

    .connect_timeout = 5s;

    .first_byte_timeout = 5s;

    .probe = {

        #health check

        .url = "/check.txt";

        .interval = 5s;

        .timeout = 5s;

        .window = 5;

        .threshold = 3;

    }

}

 

#以轮询方式实现负载均衡

director d1 round-robin {

    {

        .backend = b1;

    }

    {

        .backend = b2;

    }

}

 

#acl

acl purge {

    "localhost";

    "192.168.0.64";

}

 

sub vcl_recv {

     # 设置director

     set req.backend = d1;

     # 如果从后端返回的资源中含有Set-Cookie头的话，那么varnish不会进行缓存；如果客户端发送了Cookie头的话，那么varnish会bypass（绕开）缓存，直接发送到后端，并不会进行缓存，所以需要如下处理：

    if ( !( req.url ~ ^/admin/) ) {

        unset req.http.Cookie;

    }

 

    if (req.http.Cookie == "") {

        remove req.http.Cookie;

    }

 

    if (req.restarts == 0) {

        if (req.http.x-forwarded-for) {

            set req.http.X-Forwarded-For =

                req.http.X-Forwarded-For ", " client.ip;

        } else {

            set req.http.X-Forwarded-For = client.ip;

        }

     }

     if (req.request != "GET" &amp;&amp;

       req.request != "HEAD" &amp;&amp;

       req.request != "PUT" &amp;&amp;

       req.request != "POST" &amp;&amp;

       req.request != "TRACE" &amp;&amp;

       req.request != "OPTIONS" &amp;&amp;

       req.request != "DELETE" &amp;&amp;

       req.request != "PURGE") {

         /* Non-RFC2616 or CONNECT which is weird. */

         return (pipe);

     }

     # allow PURGE from localhost and 192.168.0...

     if (req.request == "PURGE") {

         if (!client.ip ~ purge) {

             error 405 "Not allowed.";

         }

         return (lookup);

     }

     if (req.request != "GET" &amp;&amp; req.request != "HEAD" &amp;&amp; req.request != "PURGE") {

         /* We only deal with GET and HEAD by default */

         return (pass);

     }

     if (req.http.Authorization || req.http.Cookie) {

         /* Not cacheable by default */

         return (pass);

     }

     return (lookup);

 }

 

sub vcl_hit {

     if (req.request == "PURGE") {

        # Note that setting ttl to 0 is magical.

        # the object is zapped from cache.

        set obj.ttl = 0s;

        error 200 "Purged.";

     } else {

        return (deliver);

     }

}

 

sub vcl_miss {

    if (req.request == "PURGE") {

        error 404 "Not in cache.";

    } else {

        return (fetch);

    }

}

 

sub vcl_fetch {

     #设置TTL为1个小时

     set beresp.ttl = 1h;

     if (!beresp.cacheable) {

         return (pass);

     }

     if (beresp.http.Set-Cookie) {

         return (pass);

     }

     return (deliver);

 }

 

sub vcl_deliver {

     return (deliver);

}

 

</pre>

<p><strong>启动脚本</strong></p>

<pre>#!/bin/bash

### BEGIN INIT INFO

# Author: weizhifeng

# Date: 2011.10.08

# Description: Manage the Varnishd

### END INIT INFO

 

prefix=/usr/local/varnish

bin=${prefix}/sbin/varnishd

pid=/tmp/varnish.pid

storage=2G

opts="-f ${prefix}/etc/varnish/default.vcl -T 127.0.0.1:2000 -a 0.0.0.0:80 -s file,/tmp,${storage} -P ${pid}"

 

start() {

    echo -e "Starting varnishd......"

 

    ${bin} ${opts}

 

    if [ "$?" != "0" ] ; then

        sleep 2

        echo " failed"

        exit 1

    else

        sleep 2

        echo " done"

    fi

}

 

stop() {

    if [ ! -e ${pid} ] ; then

        echo -e "Varnishd is not runningn"

        exit 0

    fi

 

    echo -e "Shutting down varnishd......"

 

    kill -QUIT $(cat ${pid})

 

    if [ -e ${pid} ] ; then

        rm -f ${pid}

    fi

 

    if [ "$?" != "0" ] ; then

        sleep 2

        echo " failed"

        exit 1

    else

        sleep 2

        echo " done"

    fi

}

 

restart() {

    stop

    start

}

 

case "$1" in

    start)

        start

    ;;

 

    stop)

        stop

    ;;

 

    restart)

        restart

    ;;

 

    *)

        echo "Usage: $0 {start|stop|restart}"

        exit 1

    ;;

esac

</pre>

<p><strong>Subroutine列表</strong></p>

<ul><li><strong>vcl_recv</strong><br/> 在请求开始时候被调用，在请求已经被接收到并且解析后调用。目的就是决定是否处理这个请求，怎么处理，使用哪个后端。vcl_recv以return结束，参数可以为如下关键字：<br/>error code [reason]：返回错误码给客户端，丢弃请求。<br/>pass：转换到pass模式。控制权最后会转移到vcl_pass。<br/>pipe：转换到pipe模式。控制权最后会转移到vcl_pipe。<br/>lookup：在缓存中寻找请求对象。控制权最后会转移到vcl_hit或者vcl_miss，决定于对象是否在缓存中。</li>

<li><strong>vcl_pipe</strong><br/>当进入pipe模式的时候被调用。在这个模式中，请求会被转移到后端，后续的数据不管是从客户端还是后端来的都会以不变的方式传送，直到连接关闭为止。vcl_pipe以return结束，参数可以为如下关键字：<br/>error code [reason]：返回错误码给客户端，丢弃请求。<br/>pipe：以pipe模式执行。</li>

<li><strong>vcl_pass</strong><br/>当进入pass模式的时候会被调用。在这个模式中，请求会被传送到后端，然后后端的响应会被传送回客户端，但是响应不会进入缓存中。接下来通过相同客户端连接发起的请求会以普通的方式来处理。vcl_pass以return结束，参数可以为如下关键字：<br/>error code [reason]：返回错误码给客户端，丢弃请求。<br/>pass：以pass模式执行。<br/>restart：重新启动这个事务。增加了重启计数。如果重启的次数高于max_restarts，varnish会引起一个错误。</li>

<li><strong>vcl_hash</strong><br/>你如果把想把数据加入到hash中，那么调用hash_data()。vcl_hash以return结束，参数可以为如下关键字：<br/>hash：执行hash逻辑。</li>

<li><strong>vcl_hit</strong><br/>如果请求的对象在缓存中被找到了，那么在缓存查找结束后被调用。vcl_hit以return结束，参数可以为如下关键字：<br/>deliver：deliver缓存对象到客户端。控制权最后会转移到vcl_deliver。<br/>error code [reason]：返回错误码给客户端，丢弃请求。<br/>pass：切换到pass模式。控制权最后会转移到vcl_pass。<br/>restart：重新启动这个事务。增加了重启计数。如果重启的次数高于max_restarts，varnish会引起一个错误。</li>

<li><strong>vcl_miss</strong><br/>如果请求的对象在缓存中没有被找到，那么在缓存查找结束后被调用。目的是为了决定是否去后端获取这个请求对象，并且要选择哪个后端。vcl_miss以return结束，参数可以为如下关键字：<br/>error code [reason]：返回错误码给客户端，丢弃请求。<br/>pass：切换到pass模式。控制权最后会转移到vcl_pass。<br/>fetch：去后端获取请求对象。控制权最后会转移到vcl_fetch。</li>

<li><strong>vcl_fetch</strong><br/>当一个对象被成功从后端获取的时候此方法会被调用。vcl_fetch以return结束，参数可以为如下关键字：<br/>deliver：可能把对象放入缓存中，然后再deliver到客户端。控制权最后会转移到vcl_deliver。<br/>error code [reason]：返回错误码给客户端，丢弃请求。<br/>esi：以ESI形式来处理刚刚被获取到的对象。<br/>pass：切换到pass模式。控制权最后会转移到vcl_pass。<br/>restart：重新启动这个事务。增加了重启计数。如果重启的次数高于max_restarts，varnish会引起一个错误。</li>

<li><strong>vcl_deliver</strong><br/>当一个缓存的对象被deliver到客户端的时候，此方法会被调用。vcl_deliver以return结束，参数可以为如下关键字：<br/>deliver：发送对象到客户端。<br/>error code [reason]：返回错误码给客户端，丢弃请求。<br/>restart：重新启动这个事务，增加重启计数。如果重启的次数高于max_restarts，varnish会引起一个错误。</li>

<li><strong>vcl_error</strong><br/>当遇见一个错误的时候会被调用，错误可能是跟后端有关系或者内部错误。vcl_error以return结束，参数可以为如下关键字：<br/>deliver：发送对象到客户端。<br/>restart：重新启动这个事务，增加重启计数。如果重启的次数高于max_restarts，varnish会引起一个错误。</li>

</ul><p><strong>重要变量</strong></p>

<p>subroutine不带参数，一般通过全局变量来实现信息的传递。</p>

<p>如下变量在<strong>backend</strong>中有效：</p>

<ul><li>.host：backend的主机名或者IP。</li>

<li>.port：backend的端口。</li>

</ul><p>如下变量在<strong>处理一个请求</strong>（例如<strong>vcl_recv</strong>）的时候可用：</p>

<ul><li>client.ip：客户端IP地址。</li>

<li>server.hostname：服务器的主机名。</li>

<li>server.identity：服务器标示，当启动varnish的时候用”-i”参数来指定。如果varnish启动时候没有指定”-i”参数，那么server.identity会被设置为用”-n”参数所指定的实例名称。</li>

<li>server.ip：服务器IP地址。</li>

<li>server.port：服务器端口。</li>

<li>req.request：请求类型（例如“GET”，“HEAD”）。</li>

<li>req.url：请求的URL。</li>

<li>req.proto：HTTP协议版本。</li>

<li>req.backend：处理请求的后端服务器。</li>

<li>req.backend.healthy：后端是否健康。health check需要在backend的probe中进行设置。</li>

<li>req.http.header：相关的HTTP头。</li>

<li>req.hash_always_miss：强迫对于本次请求的缓存查找结果为miss。如果设置为”true”，那么varnish将会忽略任何存在的缓存对象，一直从后端重新获取资源。</li>

<li>req.hash_ignore_busy：在缓存查找时候忽略任何忙的对象。如果有两个服务器，彼此互相查找缓存内容，那么可以使用这个变量来避免潜在的死锁。</li>

</ul><p>如下变量在<strong>准备一个后端请求</strong>(比如在<strong>cache miss</strong>或者<strong>pass</strong>,<strong>pipe</strong>模式)的时候可用：</p>

<ul><li>bereq.request：请求的类型（比如“GET”，“HEAD”）。</li>

<li>bereq.url：请求的URL。</li>

<li>bereq.proto：与后端服务器交互的HTTP协议版本。</li>

<li>bereq.http.header：相关的HTTP头。</li>

<li>bereq.connect_timeout：与后端连接的超时时间。</li>

<li>bereq.first_byte_timeout：从后端返回第一个字节所需等待的秒数，在pipe模式中不可用。</li>

<li>bereq.between_bytes_timeout：从后端返回的每个字节之间的时间间隔，以秒计。在pipe模式中不可用。</li>

</ul><p>如下的变量在<strong>请求对象从后端返回之后，在其被放入缓存之前</strong>可用。换句话说，也就是在<strong>vcl_fetch</strong>中可用。</p>

<ul><li>beresp.proto：HTTP协议版本。</li>

<li>beresp.status：后端返回的HTTP状态码（例如200,302等）。</li>

<li>beresp.response：后端返回的状态内容（例如“OK”，“Found”）。</li>

<li>beresp.cacheable：如果请求的结果是可以被缓存的，那么此变量为”true”。如果HTTP状态码为200, 203, 300, 301, 302, 404，410之一并且pass没有在vcl_recv中被调用，那么这个结果就是可以被缓存的。如果response的TTL和grace time都为0，那么beresp.cacheable将会为0。beresp.cacheable是可写的。</li>

<li>beresp.ttl：缓存对象的生存时间，以秒为单位，这个变量是可写的。</li>

</ul><p>在对象<strong>已经存在于缓存中并被查询到</strong>的时候，一般在<strong>vcl_hit</strong>和<strong>vcl_deliver</strong>中，如下的变量（大部分是read-only）可用：</p>

<ul><li>obj.proto：与后端交互的HTTP版本协议。</li>

<li>obj.status：后端返回的HTTP状态码。</li>

<li>obj.response：后端返回的HTTP状态内容。</li>

<li>obj.cacheable：如果对象的beresp.cacheable为”true”，那么此变量的值为”true”。除非你强制delivery，否则obj.cacheable一直为”true”。</li>

<li>obj.ttl：缓存对象的生存时间，以秒为单位，这个变量是可写的。</li>

<li>obj.lastuse：从现在到对象最近一次访问所间隔的时间，以秒为单位。</li>

<li>obj.hits：对象被发送到客户端的次数，0表示缓存查询miss了。</li>

</ul><p>如下变量在<strong>决定对象hash key</strong>的时候可用：</p>

<ul><li>req.hash：hash key被用来关联一个缓存中的对象。在读写缓存的时候都会被用到。</li>

</ul><p>如下变量在<strong>准备把一个响应发送给客户端</strong>时候可用：</p>

<ul><li>resp.proto：响应使用的HTTP协议版本。</li>

<li>resp.status：将要返回的HTTP状态码。</li>

<li>resp.response：将要返回的HTTP状态内容。</li>

<li>resp.http.header：相关的HTTP头。</li>

</ul><p><strong>Updated:<br/>2011.9.10 以轮询方式实现负载均衡<br/>2011.10.08 启动脚本优化</strong></p>
