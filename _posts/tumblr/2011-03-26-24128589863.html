---
layout: post
title: HAR(HTTP Archive)规范
---

<p>HAR（HTTP Archive），是一个用来储存HTTP请求/响应信息的通用文件格式，基于<a href="http://www.ietf.org/rfc/rfc4627.txt" target="_blank">JSON</a>。这个格式的出现可以使HTTP监测工具以一种通用的格式导出所收集的数据，这些数据可以被其他支持HAR的HTTP<a href="http://www.softwareishard.com/blog/har-adopters/" target="_blank">分析工具</a>（包括Firebug,httpwatch,Fiddler等）所使用，来分析网站的性能瓶颈。目前HAR规范最新版本为<a href="http://www.softwareishard.com/blog/har-12-spec/" target="_blank">HAR 1.2</a>。HAR文件必须是UTF-8编码，有无BOM无所谓。<span id="more-245"></span></p>

<h3>HAR数据结构：</h3>

<p>一个HAR文件就是一个JSON对象，如下：</p>

<pre>{

    "log": {

        "version" : "1.2",

        "creator" : {},

        "browser" : {},

        "pages": [],

        "entries": [],

        "comment": "

    }

}

</pre>

<ul><li>version [string] – 版本，默认为1.1。</li>

<li>creator [object] – 创建HAR文件的程序名称和版本信息。</li>

<li>browser [object, 可选] – 浏览器的名称和版本信息。</li>

<li>pages [array, 可选] – 页面列表，如果应用不支持按照page分组，可以省去此字段。</li>

<li>entries [array] – 所有HTTP请求的列表。</li>

<li>comment [string, 可选] (new in 1.2) – 注释。</li>

</ul><p>注：每个页面对应一个 对象，每个HTTP请求对应一个对象。如果HTTP的监测分析工具不能把请求按照page分组，那么 为空。</p>

<p><strong>&lt;creator&gt; &amp; &lt;browser&gt;</strong><br/>这两个对象的结构是一样的</p>

<pre>"creator": {

    "name": "Firebug",

    "version": "1.6",

    "comment": ",

}

 

"browser": {

    "name": "Firefox",

    "version": "3.6",

    "comment": "

}

</pre>

<ul><li>name [string] – HAR生成工具或者浏览器的名称。</li>

<li>version [string] – HAR生成工具或者浏览器的版本。</li>

<li>comment [string, 可选] (new in 1.2) – 注释。</li>

</ul><p><strong>&lt;pages&gt;</strong><br/>这个对象保存了页面列表，格式如下：</p>

<pre>"pages": [

    {

        "startedDateTime": "2009-04-16T12:07:25.123+01:00",

        "id": "page_0",

        "title": "Test Page",

        "pageTimings": {...},

        "comment": "

    }

]

</pre>

<ul><li>startedDateTime [string] – 页面开始加载的时间(格式ISO 8601 – YYYY-MM-DDThh:mm:ss.sTZD, 例如2009-07-24T19:20:30.45+01:00)。</li>

<li>id [string] – page的唯一标示，entry会用到这个id来和page关联在一起。</li>

<li>title [string] – 页面标题。</li>

<li>pageTimings[object] – 页面加载过程中详细的时间信息。</li>

<li>comment [string, 可选] (new in 1.2) – 注释。</li>

</ul><p><strong>&lt;pageTimings&gt;</strong><br/>这个对象描述了在页面加载过程中各个事件发生的时间点。所有的时间都是以毫秒计算的。如果有的时间无法计算出来，那么相应字段置为-1。</p>

<pre>"pageTimings": [

    {

        "onContentLoad": 1720,

        "onLoad": 2500,

        "comment": "

    }

]

</pre>

<ul><li>onContentLoad [number, 可选] – 页面内容加载时间，相对于页面开始加载时间的毫秒数（page.startedDateTime）。如果时间不适用于当前的请求，那么置为-1。</li>

<li>onLoad [number,可选] – 页面加载时间（即onLoad事件触发的时间）。相对于页面开始加载时间的毫秒数（page.startedDateTime）。如果时间不适用于当前的请求，那么置为-1。</li>

<li>comment [string, 可选] (new in 1.2) – 注释。</li>

</ul><p>由于不同浏览器实现不一样，onContentLoad属性可能代表<strong>DOMContentLoad</strong>事件触发，也可能代表document.readyState等于<strong>interactive</strong>。</p>

<p><strong>&lt;entries&gt;</strong><br/>这个对象包含了一个数组，数组中每个元素的内容就是一个HTTP请求的相应信息。用startedDateTime来排序的话可以加快数据导出的速度。HAR分析工具要确保此数组是按照startedDateTime排序的。</p>

<pre>"entries": [

    {

        "pageref": "page_0",

        "startedDateTime": "2009-04-16T12:07:23.596Z",

        "time": 50,

        "request": {...},

        "response": {...},

        "cache": {...},

        "timings": {},

        "serverIPAddress": "10.0.0.1",

        "connection": "52492",

        "comment": "

    }

]

</pre>

<ul><li>pageref [string, unique, 可选] – 页面id，如果不支持按照page分组，那么字段为空。</li>

<li>startedDateTime [string] – 请求开始时间 (格式ISO 8601 – YYYY-MM-DDThh:mm:ss.sTZD)。</li>

<li>time [number] – 请求消耗的时间，以毫秒为单位。这个值是timings对象中所有可用(值不为-1) timing的和。</li>

<li>request [object] – 请求的详细信息。</li>

<li>response [object] – 响应的详细信息。</li>

<li>cache [object] – 缓存使用情况的信息。</li>

<li>timings [object] – 请求/响应过程（round trip）的详细时间信息。</li>

<li>serverIPAddress [string, 可选] (new in 1.2) – 服务器IP地址。</li>

<li>connection [string, 可选] (new in 1.2) – TCP/IP连接的唯一标示。 如果程序不支持，直接忽略此字段。</li>

<li>comment [string, optional] (new in 1.2) – 注释。</li>

</ul><p><strong>&lt;request&gt;</strong><br/>这个对象包含了请求的详细信息</p>

<pre>"request": {

    "method": "GET",

    "url": "http://www.example.com/path/?param=value",

    "httpVersion": "HTTP/1.1",

    "cookies": [],

    "headers": [],

    "queryString" : [],

    "postData" : {},

    "headersSize" : 150,

    "bodySize" : 0,

    "comment" : ",

}

</pre>

<ul><li>method [string] – 请求方法(GET, POST, …)。</li>

<li>url [string] – 请求的绝对URL(fragments are not included)。</li>

<li>httpVersion [string] – 请求HTTP版本。</li>

<li>cookies [array] – cookie列表。</li>

<li>headers [array] – header列表。</li>

<li>queryString [object] – 查询字符串信息。</li>

<li>postData [object, 可选] – Post数据信息。</li>

<li>headersSize [number] – HTTP请求头的字节数。如果不可用，设置为-1。</li>

<li>bodySize [number] – 请求body字节数（POST数据）。如果不可用，设置为-1。</li>

<li>comment [string, 可选] (new in 1.2) – 注释。</li>

</ul><p><strong>&lt;response&gt;</strong><br/>这个对象包含响应的详细信息。</p>

<pre>"response": {

    "status": 200,

    "statusText": "OK",

    "httpVersion": "HTTP/1.1",

    "cookies": [],

    "headers": [],

    "content": {},

    "redirectURL": ",

    "headersSize" : 160,

    "bodySize" : 850,

    "comment" : "

 }

</pre>

<ul><li>status [number] – 响应状态。</li>

<li>statusText [string] – 响应状态描述。</li>

<li>httpVersion [string] – HTTP版本。</li>

<li>cookies [array] – cookie列表。</li>

<li>headers [array] – header列表。</li>

<li>content [object] – 响应内容的详细信息。</li>

<li>redirectURL [string] – Location响应头中的重定向URL。</li>

<li>headersSize [number]* – HTTP请求头的字节数。如果不可用，设置为-1。</li>

<li>bodySize [number] – 接收的body字节数。如果响应来自缓存(304)，那么设置为0。如果不可用，设置为-1。</li>

<li>comment [string, optional] (new in 1.2) – 注释。</li>

</ul><p>注：headersSize – 响应头大小只对从服务器接收到的header进行计算。被浏览器加上的header不计算在内，但是会加在header列表中。</p>

<p><strong>&lt;cookies&gt;</strong><br/>这个对象包含了所有的cookie（在和中被使用）。</p>

<pre>"cookies": [

    {

        "name": "TestCookie",

        "value": "Cookie Value",

        "path": "/",

        "domain": "www.janodvarko.cz",

        "expires": "2009-07-24T19:20:30.123+02:00",

        "httpOnly": false,

        "secure": false,

        "comment": ",

    }

]

</pre>

<ul><li>name [string] – cookie名称。</li>

<li>value [string] – cookie值。</li>

<li>path [string, 可选] – cookie Path。</li>

<li>domain [string, 可选] – cookie域名。</li>

<li>expires [string, 可选] – cookie过期时间。(格式ISO 8601 – YYYY-MM-DDThh:mm:ss.sTZD, 例如2009-07-24T19:20:30.123+02:00)。</li>

<li>httpOnly [boolean, 可选] – 如果cookie只是在HTTP下有效，此值设置为true，否则设置为false。</li>

<li>secure [boolean, 可选] (new in 1.2) – 如果cookie通过ssl传送，此值设置为true，否则设置为false。</li>

<li>comment [string, 可选] (new in 1.2) – 注释。</li>

</ul><p><strong>&lt;headers&gt;</strong><br/>这个对象包含了所有的header（可以在 and 中使用）</p>

<pre>"headers": [

    {

        "name": "Accept-Encoding",

        "value": "gzip,deflate",

        "comment": "

    },

    {

        "name": "Accept-Language",

        "value": "en-us,en;q=0.5",

        "comment": "

    }

]

</pre>

<p><strong>&lt;queryString&gt;</strong><br/>这个对象包含了查询字符串中所有的paramter-value对（嵌在对象中）。</p>

<pre>"queryString": [

    {

        "name": "param1",

        "value": "value1",

        "comment": "

    },

    {

        "name": "param1",

        "value": "value1",

        "comment": "

    }

]

</pre>

<p><strong>&lt;postData&gt;</strong><br/>这个对象描述了POST的数据（嵌在对象中）</p>

<pre>"postData": {

    "mimeType": "multipart/form-data",

    "params": [],

    "text" : "plain posted data",

    "comment": "

}

</pre>

<ul><li>mimeType [string] – POST数据的MIME类型。</li>

<li>params [array] – POST参数列表 (in case of URL encoded parameters)。</li>

<li>text [string] – POST数据的纯文本形式(Plain text posted data)。</li>

<li>comment [string, optional] (new in 1.2) – 注释。</li>

</ul><p>注意：text和params字段是互斥的。</p>

<p><strong>&lt;params&gt;</strong><br/>POST请求参数列表（嵌在 对象中）</p>

<pre>"params": [

    {

        "name": "paramName",

        "value": "paramValue",

        "fileName": "example.pdf",

        "contentType": "application/pdf",

        "comment": "

    }

]

</pre>

<ul><li>name [string] – POST参数名。</li>

<li>value [string, 可选] – POST参数的值，或者POST文件的内容。</li>

<li>fileName [string, 可选] – POST文件的文件名。</li>

<li>contentType [string, 可选] – POST文件的类型。</li>

<li>comment [string, 可选] (new in 1.2) – 注释。</li>

</ul><p><strong>&lt;content&gt;</strong><br/>这个对象描述了响应内容的详细情况（嵌在 对象中）</p>

<pre>"content": {

    "size": 33,

    "compression": 0,

    "mimeType": "text/html; charset="utf-8",

    "text": "n",

    "comment": "

}

</pre>

<ul><li>size [number] – 返回内容的字节数。如果内容没有被压缩，应该和response.bodySize相等；如果被压缩，那么会大于response.bodySize。</li>

<li>compression [number, 可选] – 节省的字节数。如果无法提供此信息，则忽略此字段。</li>

<li>mimeType [string] – 响应文本的MIME类型 (Content-Type响应头的值)。MIMIE类型的字符集也包含在内。</li>

<li>text [string, 可选] – 从服务器返回的响应body或者从浏览器缓存加载的内容。这个字段只能用文本型的内容来填充。字段内容可以是HTTP decoded(decompressed &amp; unchunked)的文本，或者是经编码（例如，base64）过的响应内容。如果信息不可用，忽略此字段。</li>

<li>encoding [string, 可选] (new in 1.2) – 响应内容的编码格式，例如”base64″。如果text字段的内容是经过了HTTP解码(decompressed &amp; unchunked)的，那么忽略此字段。</li>

<li>comment [string, optional] (new in 1.2) – 注释。</li>

</ul><p>在设置text字段之前，HTTP响应内容已经完成了解码(decompressed &amp; unchunked)，然后把原始字符编码转换成UTF-8。字段内容同样可以使用base64进行编码，但是HAR工具必须有解码base64的能力。 对字段编码还可以把二进制内容包含进HAR文件中。</p>

<p>这有另一个例子，原始响应内容是：<br/>n</p>

<pre>"content": {

    "size": 33,

    "compression": 0,

    "mimeType": "text/html; charset="utf-8",

    "text": "PGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5Lz48L2h0bWw+XG4=",

    "encoding": "base64",

    "comment": "

}

</pre>

<p><strong>&lt;cache&gt;</strong><br/>这个对象包含了命中的浏览器缓存信息</p>

<pre>"cache": {

    "beforeRequest": {},

    "afterRequest": {},

    "comment": "

}

</pre>

<ul><li>beforeRequest [object, 可选] – 在请求之前缓存的状态。如果信息不可用，可以忽略此字段。</li>

<li>afterRequest [object, 可选] – 在请求之后缓存的状态。 如果信息不可用，可以忽略此字段。</li>

<li>comment [string, 可选] (new in 1.2) – 注释。</li>

</ul><p>如果缓存信息为空，那么对象如下（或者也可以直接删掉cache这个字段）：</p>

<pre>"cache": {}

</pre>

<p>如果在请求之前，缓存信息不可用，并且在请求之后也没有对内容进行缓存，那么对象如下：</p>

<pre>"cache": {

"afterRequest": null

}

</pre>

<p>如果在请求前后都没有缓存存在，那么对象如下：</p>

<pre>"cache": {

    "beforeRequest": null,

    "afterRequest": null

}

</pre>

<p>以下对象表示请求之前没有缓存，但是在请求后，下载的内容被存在了本地缓存中。</p>

<pre>"cache": {

    "beforeRequest": null,

    "afterRequest": {

        "expires": "2009-04-16T15:50:36",

        "lastAccess": "2009-16-02T15:50:34",

        "eTag": ",

        "hitCount": 0,

        "comment": "

    }

}

</pre>

<p>beforeRequest和afterRequest对象使用以下相同的结构：</p>

<pre>"beforeRequest": {

    "expires": "2009-04-16T15:50:36",

    "lastAccess": "2009-16-02T15:50:34",

    "eTag": ",

    "hitCount": 0,

    "comment": "

}

</pre>

<ul><li>expires [string, 可选] – 缓存过期时间。</li>

<li>lastAccess [string] – 缓存最后被访问的时间。</li>

<li>eTag [string] – Etag</li>

<li>hitCount [number] – 缓存被访问的次数。</li>

<li>comment [string, 可选] (new in 1.2) – 注释</li>

</ul><p><strong>&lt;timings&gt;</strong><br/>这个对象描述了请求/响应过程的各个阶段。时间都是以毫秒为单位。</p>

<pre>"timings": {

    "blocked": 0,

    "dns": -1,

    "connect": 15,

    "send": 20,

    "wait": 38,

    "receive": 12,

    "ssl": -1,

    "comment": "

}

</pre>

<ul><li>blocked [number, 可选] – 建立网络连接时在队列里边等待的时间。如果时间对于当前请求不可用，置为-1。</li>

<li>dns [number, 可选] – DNS查询时间。如果时间对于当前请求不可用，置为-1。</li>

<li>connect [number, 可选] – 建立TCP连接所需的时间。如果时间对于当前请求不可用，置为-1。</li>

<li>send [number] – 发送HTTP请求到服务器所需的时间。</li>

<li>wait [number] – 等待服务器返回响应的时间。</li>

<li>receive [number] – 接收服务器响应（或者缓存）所需时间。</li>

<li>ssl [number, 可选] (new in 1.2) – SSL/TLS验证花费时间。如果这个字段被定义了，那么这个时间也会被包含进connect字段中(为了向后兼容HAR1.1)。如果时间对于当前请求不可用，置为-1。</li>

<li>comment [string, 可选] (new in 1.2) – 注释。</li>

</ul><p><strong>send</strong>, <strong>wait</strong>, <strong>receive</strong>时间是必须提供的，并且不能为负数。导出工具如果不能提供 blocked,dns,connect和ssl等时间，那么这些时间可以被忽略。如果工具可以提供这些时间，但是不适用的话，可以把这些值设置为-1。 例如，当请求使用了一个存在的连接，connect会被置为-1。<br/>一个请求所花的时间等于这些时间的和，不包括值为-1的。<br/><strong>entry.time == entry.timings.blocked + entry.timings.dns + entry.timings.connect + entry.timings.send + entry.timings.wait + entry.timings.receive</strong></p>

<h3>自定义字段</h3>

<p>HAR规范允许自定义字段，但是要遵循如下规则：</p>

<ul><li>自定义字段（field）和元素（element）必须以下划线开头(规范中的字段必须不能以下划线开头)</li>

<li>HAR工具必须忽略所有自定义字段和元素，如果这个HAR文件不是当前HAR工具生成的。</li>

<li>当HAR工具不知道如何解析非自定义字段的时候，忽略它们。</li>

<li>当文件包含了已经被废弃的非自定义字段时候，HAR工具可以拒绝解析此文件。</li>

</ul><h3>版本格式</h3>

<p>HAR规范的版本号有如下规则：<br/>&lt;主版本号&gt;.&lt;副版本号&gt;<br/>主版本号表示规范的向后兼容性，副版本号表示增量修改。所以，任何向后兼容的修改都会增加副版本号。如果一个存在的字段被废弃了，那么主版本号要增加(例如2.0)。</p>

<p>Examples:<br/>1.2 -&gt; 1.3(向后兼容)<br/>1.111 -&gt; 1.112 (向后兼容)<br/>1.5 -&gt; 2.0 (2.0不兼容1.5)<br/>如果HAR工具只支持HAR1.1，那么以下的代码可以被用来检测不被兼容的版本。<br/>if (majorVersion&#160;!= 1 || minorVersion &lt; 1)<br/>{<br/>throw “Incompatible version”;<br/>}<br/>这个例子中，如果被解析文件的版本为0.8,0.9,1.0等，那么工具会抛出异常，但是1.1, 1.2, 1.112等版本可以被解析。2.x版本直接拒绝解析。</p>

<p>原文：http://www.softwareishard.com/blog/har-12-spec/<br/>Google Group: <a href="http://groups.google.com/group/http-archive-specification%E3%80%90%E9%9C%80%E7%BF%BB%E5%A2%99%E3%80%91" target="_blank">http://groups.google.com/group/http-archive-specification【需翻墙】</a></p>
