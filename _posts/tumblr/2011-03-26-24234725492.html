---
layout: post
title: 使用Awstats分析Nginx日志
---

<p>Awstats是用Perl开发的，功能强大的服务器日志分析工具，但是默认只支持Apache和IIS，本文介绍下如何用其来分析Nginx日志，并且在Nginx下运行awstats。由于Nginx没有内置的Perl执行能力，我们采用Fastcgi来执行Perl。</p>

<p><strong>1.创建Fastcgi-fpm</strong></p>

<p>确保机器上已经安装了Perl和cpan，输入cpan，然后安装PerlFCGI和FCGI::ProcManager两个包：</p>

<pre>cpan&gt;install FCGI

cpan&gt;install FCGI::ProcManager

</pre>

<p>创建文件/usr/local/bin/cgiwrap-fcgi.pl，作为Fastcgi-fpm：</p>

<pre>#!/usr/bin/perl

use FCGI;

use Socket;

use FCGI::ProcManager;

sub shutdown { FCGI::CloseSocket($socket); exit; }

sub restart  { FCGI::CloseSocket($socket); &amp;main; }

use sigtrap 'handler', &amp;shutdown, 'normal-signals';

use sigtrap 'handler', &amp;restart,  'HUP';

require 'syscall.ph';

use POSIX qw(setsid);



END()   { }

BEGIN() { }

{

  no warnings;

  *CORE::GLOBAL::exit = sub { die "fakeexitnrc=" . shift() . "n"; };

};



eval q{exit};

if ($@) {

  exit unless $@ =~ /^fakeexit/;

}

&amp;main;



sub daemonize() {

  chdir '/' or die "Can't chdir to /: $!";

  defined( my $pid = fork ) or die "Can't fork: $!";

  exit if $pid;

  setsid() or die "Can't start a new session: $!";

  umask 0;

}



sub main {

  $proc_manager = FCGI::ProcManager-&gt;new( {n_processes =&gt; 5} );

  $socket = FCGI::OpenSocket( "/var/run/nginx/cgiwrap-dispatch.sock", 10 )

  ; #use UNIX sockets - user running this script must have w access to the 'nginx' folder!!

  $request =

  FCGI::Request( *STDIN, *STDOUT, *STDERR, %req_params, $socket,

  &amp;FCGI::FAIL_ACCEPT_ON_INTR );

  $proc_manager-&gt;pm_manage();

  if ($request) { request_loop() }

  FCGI::CloseSocket($socket);

}



sub request_loop {

  while ( $request-&gt;Accept() &gt;= 0 ) {

    $proc_manager-&gt;pm_pre_dispatch();



    #processing any STDIN input from WebServer (for CGI-POST actions)

    $stdin_passthrough = '';

    { no warnings; $req_len = 0 + $req_params{'CONTENT_LENGTH'}; };

    if ( ( $req_params{'REQUEST_METHOD'} eq 'POST' ) &amp;&amp; ( $req_len != 0 ) ) {

      my $bytes_read = 0;

      while ( $bytes_read &lt; $req_len ) {

        my $data = '';

        my $bytes = read( STDIN, $data, ( $req_len - $bytes_read ) );

        last if ( $bytes == 0 || !defined($bytes) );

        $stdin_passthrough .= $data;

        $bytes_read += $bytes;

      }

    }



    #running the cgi app

    if (

      ( -x $req_params{SCRIPT_FILENAME} ) &amp;&amp;    #can I execute this?

      ( -s $req_params{SCRIPT_FILENAME} ) &amp;&amp;    #Is this file empty?

      ( -r $req_params{SCRIPT_FILENAME} )       #can I read this file?

    ) {

      pipe( CHILD_RD,   PARENT_WR );

      pipe( PARENT_ERR, CHILD_ERR );

      my $pid = open( CHILD_O, "-|" );

      unless ( defined($pid) ) {

        print("Content-type: text/plainrnrn");

        print "Error: CGI app returned no output - Executing $req_params{SCRIPT_FILENAME} failed !n";

        next;

      }

      $oldfh = select(PARENT_ERR);

      $|     = 1;

      select(CHILD_O);

      $| = 1;

      select($oldfh);

      if ( $pid &gt; 0 ) {

        close(CHILD_RD);

        close(CHILD_ERR);

        print PARENT_WR $stdin_passthrough;

        close(PARENT_WR);

        $rin = $rout = $ein = $eout = '';

        vec( $rin, fileno(CHILD_O),    1 ) = 1;

        vec( $rin, fileno(PARENT_ERR), 1 ) = 1;

        $ein    = $rin;

        $nfound = 0;



        while ( $nfound = select( $rout = $rin, undef, $ein = $eout, 10 ) ) {

          die "$!" unless $nfound != -1;

          $r1 = vec( $rout, fileno(PARENT_ERR), 1 ) == 1;

          $r2 = vec( $rout, fileno(CHILD_O),    1 ) == 1;

          $e1 = vec( $eout, fileno(PARENT_ERR), 1 ) == 1;

          $e2 = vec( $eout, fileno(CHILD_O),    1 ) == 1;



          if ($r1) {

            while ( $bytes = read( PARENT_ERR, $errbytes, 4096 ) ) {

              print STDERR $errbytes;

            }

            if ($!) {

              $err = $!;

              die $!;

              vec( $rin, fileno(PARENT_ERR), 1 ) = 0

              unless ( $err == EINTR or $err == EAGAIN );

            }

          }

          if ($r2) {

            while ( $bytes = read( CHILD_O, $s, 4096 ) ) {

              print $s;

            }

            if ( !defined($bytes) ) {

              $err = $!;

              die $!;

              vec( $rin, fileno(CHILD_O), 1 ) = 0

              unless ( $err == EINTR or $err == EAGAIN );

            }

          }

          last if ( $e1 || $e2 );

        }

        close CHILD_RD;

        close PARENT_ERR;

        waitpid( $pid, 0 );

      } else {

        foreach $key ( keys %req_params ) {

          $ENV{$key} = $req_params{$key};

        }



        # cd to the script's local directory

        if ( $req_params{SCRIPT_FILENAME} =~ /^(.*)/[^/] +$/ ) {

          chdir $1;

        }

        close(PARENT_WR);

        #close(PARENT_ERR);

        close(STDIN);

        close(STDERR);



        #fcntl(CHILD_RD, F_DUPFD, 0);

        syscall( &amp;SYS_dup2, fileno(CHILD_RD),  0 );

        syscall( &amp;SYS_dup2, fileno(CHILD_ERR), 2 );



        #open(STDIN, "&lt;&amp;CHILD_RD");

        exec( $req_params{SCRIPT_FILENAME} );

        die("exec failed");

      }

    } else {

      print("Content-type: text/plainrnrn");

      print "Error: No such CGI app - $req_params{SCRIPT_FILENAME} may not exist or is not executable by this process.n";

    }

  }

}

&lt;/pre&gt;

</pre>

<p>赋予cgiwrap-fcgi.pl执行权限</p>

<pre>chmod 755 /usr/local/bin/cgiwrap-fcgi.pl

mkdir -p /var/run/nginx/

</pre>

<p>启动FPM，Nginx需要对socket有读写权限，否则会报502错误</p>

<pre>/usr/local/bin/cgiwrap-fcgi.pl &gt; /dev/null 2&gt;&amp;1 &amp;;

chown -R www:www /var/run/nginx/cgiwrap-dispatch.sock

</pre>

<p><strong>2. Awstats安装配置：</strong></p>

<pre>cd /usr/local

wget <a href="http://prdownloads.sourceforge.net/awstats/awstats-7.0.tar.gz" target="_blank">http://prdownloads.sourceforge.net/awstats/awstats-7.0.tar.gz</a>

tar -zxvf awstats-7.0.tar.gz

mv awstats-7.0 awstats

</pre>

<p>执行/usr/local/awstats/tools/awstats_configure.pl，进行awstats配置。系统会提示选择日志格式种类，目前awstats默认只支持Apache和IIS，由于是Nginx，所以选择none；按要求输入自己的域名，假设为example.com，那么会在/etc/awstats/下面生成/etc/awstats/awstats.example.com.conf的配置文件。 修改配置文件/etc/awstats/awstats.example.com.conf，添加如下内容：</p>

<pre>#指定日志文件位置，因为我们要在凌晨1点分析日志，所以要指定的是前一天的日志文件

LogFile="/usr/local/nginx/logs/access_%YYYY-0%MM-0%DD-24.log"

#日志格式，需要与Nginx中的日志格式一致

LogFormat="%host - %time1 %methodurl %code %bytesd %refererquot %uaquot"

</pre>

<p>创建切割日志脚本/usr/local/nginx/sbin/logcron.sh：</p>

<pre>#!/bin/bash

# 日志切割脚本

mv /usr/local/nginx/logs/access.log /usr/local/nginx/logs/access_`date +%Y%m%d`.log

kill -s SIGUSR1 `cat /usr/local/nginx/nginx.pid`

</pre>

<p>创建awstats日志更新脚本/usr/local/nginx/sbin/awstats_up.sh&#160;:</p>

<pre>#!/bin/bash

# 更新awstats日志

/usr/local/awstats/wwwroot/cgi-bin/awstats.pl -update -config=example.com

</pre>

<p>添加crontab任务，内容如下：</p>

<pre>#23:59切割nginx日志

59 23 * * * /usr/local/nginx/sbin/logcron.sh



# 1点开始生成awstats统计数据

00 1 * * * /usr/local/nginx/sbin/awstats_up.sh

</pre>

<p><strong>3. 配置Nginx</strong></p>

<p>修改Nginx配置/usr/local/nginx/conf/nginx.conf，添加如下内容：</p>

<pre>#log格式，注意空格，这个格式必须与awstats中的LogFormat一样

log_format  main     '$remote_addr - [$time_local] "$request" '

'$status $body_bytes_sent "$http_referer" '

'"$http_user_agent" $http_x_forwarded_for';

access_log logs/access.log main;

#awstats运行配置

server {

    listen 127.0.0.1:80;

    server_name awstats.com;

    access_log off;

    error_log off;



    root  /usr/local/awstats/wwwroot;

    index index.html;



    location ~ ^/cgi-bin/.*.cgi$ {

        gzip off;

        fastcgi_pass  unix:/var/run/nginx/cgiwrap-dispatch.sock;

        fastcgi_index index.cgi;

        include fastcgi_params;

    }

}

</pre>

<p>修改Fastcgi配置/usr/local/nginx/conf/fastcgi_params，添加如下内容：</p>

<pre>fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;

fastcgi_param  QUERY_STRING       $query_string;

fastcgi_param  REQUEST_METHOD     $request_method;

fastcgi_param  CONTENT_TYPE       $content_type;

fastcgi_param  CONTENT_LENGTH     $content_length;



fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;

fastcgi_param  REQUEST_URI        $request_uri;

fastcgi_param  DOCUMENT_URI       $document_uri;

fastcgi_param  DOCUMENT_ROOT      $document_root;

fastcgi_param  SERVER_PROTOCOL    $server_protocol;



fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;

fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;



fastcgi_param  REMOTE_ADDR        $remote_addr;

fastcgi_param  REMOTE_PORT        $remote_port;

fastcgi_param  SERVER_ADDR        $server_addr;

fastcgi_param  SERVER_PORT        $server_port;

fastcgi_param  SERVER_NAME        $server_name;



# PHP only, required if PHP was built with --enable-force-cgi-redirect

fastcgi_param  REDIRECT_STATUS    200;

</pre>

<p>访问方式：http://example.com/cgi-bin/awstats.pl?config=example.com</p>

<p>参考：<br/> <a href="http://wiki.nginx.org/NginxSimpleCGI" target="_blank">http://wiki.nginx.org/NginxSimpleCGI</a><br/> <a href="http://5ydycm.blog.51cto.com/115934/140029" target="_blank">http://5ydycm.blog.51cto.com/115934/140029</a></p>
